# 기본 기능 상세 구현 문서

## 목차
1. [서버 구현](#서버-구현)
2. [클라이언트 구현](#클라이언트-구현)
3. [장치 제어 라이브러리 구현](#장치-제어-라이브러리-구현)
4. [통신 프로토콜](#통신-프로토콜)

---

## 서버 구현

### 1. 서버 구조 개요

**파일**: `code/server/server.c`

서버는 다음과 같은 구조로 구현되어 있습니다:
- **데몬 프로세스**: 백그라운드에서 실행
- **멀티 스레드**: 클라이언트별 처리 스레드, CDS 센서 모니터링 스레드, 7세그먼트 카운트다운 스레드
- **동적 라이브러리 로딩**: `dlopen/dlsym`을 사용하여 장치 제어 함수 동적 로드
- **클라이언트 목록 관리**: 연결된 클라이언트 목록을 관리하고 브로드캐스트 지원

### 2. 주요 전역 변수

```c
int server_socket = -1;  // 서버 소켓

// CDS 센서 모니터링 스레드 관련
volatile int cds_monitor_running = 0;
volatile int cds_thread_created = 0;
pthread_t cds_monitor_thread;
pthread_mutex_t cds_monitor_mutex = PTHREAD_MUTEX_INITIALIZER;

// 7세그먼트 카운트다운 스레드 관련
volatile int segment_countdown_running = 0;
volatile int segment_thread_created = 0;
pthread_t segment_countdown_thread;
pthread_mutex_t segment_countdown_mutex = PTHREAD_MUTEX_INITIALIZER;

// 클라이언트 목록 관리
typedef struct ClientList {
    int socket_fd;
    struct ClientList *next;
} ClientList;

ClientList *client_list_head = NULL;
pthread_mutex_t client_list_mutex = PTHREAD_MUTEX_INITIALIZER;

// 장치 라이브러리 함수 포인터
DeviceLibs g_libs = {0};
```

### 3. 실행 파일 경로 계산

**함수**: `get_exe_directory()`

**핵심 로직**:
- `/proc/self/exe` 심볼릭 링크를 통해 실행 파일의 절대 경로 획득
- `readlink()`로 경로 읽기 → `dirname()`으로 디렉토리 경로 추출
- 정적 변수로 캐싱하여 재사용
- 실패 시 `getcwd()`로 현재 작업 디렉토리 사용

**역할**:
- 데몬 프로세스에서도 정확한 경로를 얻기 위해 사용
- 라이브러리, 로그 파일, PID 파일 경로 계산에 사용

### 4. 로그 파일 관리

**함수**: `get_log_file_path()`, `log_event()`

**핵심 로직**:
- `get_log_file_path()`: 실행 파일 디렉토리의 부모 디렉토리 + `/misc/device_server.log` 경로 생성
- `log_event()`: 타임스탬프(`[HH:MM:SS]`)와 함께 로그 파일에 메시지 기록

**역할**:
- 데몬 프로세스는 화면 출력이 불가능하므로 모든 출력을 로그 파일에 기록
- 실행 파일 기준 상대 경로로 로그 파일 위치 결정

### 5. 동적 라이브러리 로딩

**함수**: `load_library()`, `load_symbols()`

**핵심 로직**:
- `load_library()`: `dlopen(lib_path, RTLD_LAZY)`로 동적 라이브러리 로드
- `load_symbols()`:
  1. 실행 파일 디렉토리 기준으로 `lib/libdevice_manage.so` 경로 구성
  2. `dlsym()`으로 각 장치 제어 함수 심볼 로드 (LED, 부저, 7세그먼트, CDS 센서)
  3. 필수 심볼 로딩 확인 후 `device_init_all()` 호출

**역할**:
- 런타임에 장치 제어 함수 동적 로드
- 함수 포인터를 통해 장치 제어 함수 호출
- 라이브러리 변경 시 재컴파일 없이 업데이트 가능

### 6. 클라이언트 목록 관리

**함수**: `add_client_to_list()`, `remove_client_from_list()`, `broadcast_to_clients()`

**핵심 로직**:
- **추가**: 새 클라이언트 노드를 할당하여 링크드 리스트 헤드에 추가 (뮤텍스 보호)
- **제거**: 소켓 파일 디스크립터로 노드 검색 후 제거 (뮤텍스 보호)
- **브로드캐스트**: 모든 클라이언트 노드를 순회하며 `send()`로 메시지 전송, 전송 실패 시 목록에서 자동 제거

**역할**:
- 연결된 클라이언트를 링크드 리스트로 관리
- 뮤텍스로 스레드 안전성 보장
- 모든 클라이언트에 메시지 브로드캐스트 (CDS 센서 값 변경 시 사용)
- 연결이 끊어진 클라이언트 자동 제거

### 7. 명령 처리

**함수**: `handle_command()`

**핵심 로직**:
- `strncmp()`로 명령 문자열 비교
- LED/부저/7세그먼트: 직접 장치 제어 함수 호출
- SEGMENT_COUNTDOWN/SENSOR_ON: 별도 스레드 생성 및 실행 플래그 설정
- SEGMENT_STOP/SENSOR_OFF: 실행 플래그 해제 및 스레드 종료 대기
- 각 명령에 대해 성공/실패 응답 메시지 반환

**처리 패턴**:
```c
if (strncmp(cmd, "COMMAND_NAME", len) == 0) {
    // 명령 처리
    return "RESPONSE MESSAGE\n";
}
```

**역할**:
- 클라이언트로부터 받은 문자열 명령을 파싱
- 해당하는 장치 제어 함수 호출 또는 스레드 제어
- 결과 메시지 반환

### 8. 클라이언트 처리 스레드

**함수**: `handle_client()`

**핵심 로직**:
1. 클라이언트 목록에 추가 및 연결 로그 기록
2. `recv()`로 명령 수신 루프
3. 수신한 명령을 `handle_command()`로 처리
4. 처리 결과를 `send()`로 클라이언트에 전송
5. 연결 종료 시 목록에서 제거 및 소켓 닫기

**역할**:
- 각 클라이언트마다 별도 스레드 생성
- 클라이언트로부터 명령 수신 및 처리
- 명령 처리 후 응답 전송
- 연결 종료 시 정리

### 9. CDS 센서 모니터링 스레드

**함수**: `cds_monitor_thread_func()`

**핵심 로직**:
1. 실행 플래그 설정 후 루프 진입
2. `sensor_get_value()`로 센서 값 읽기 (100ms 간격)
3. 이전 값과 비교하여 변경 시에만 처리:
   - 빛 없음(0) → `led_on()` 호출
   - 빛 감지(1) → `led_off()` 호출
   - 모든 클라이언트에 브로드캐스트
4. `cds_monitor_running` 플래그가 0이 되면 종료

**역할**:
- 100ms 간격으로 CDS 센서 값 읽기
- 값 변경 시 LED 자동 제어
- 모든 클라이언트에 브로드캐스트
- `SENSOR_OFF` 명령 시 종료

### 10. 7세그먼트 카운트다운 스레드

**함수**: `segment_countdown_thread_func()`

**핵심 로직**:
1. 시작 숫자를 인자로 받아 실행 플래그 설정
2. 시작 숫자부터 0까지 반복:
   - `segment_display(n)`으로 숫자 표시
   - 모든 클라이언트에 카운트다운 상태 브로드캐스트
   - 1초 대기 (`sleep(1)`)
3. 0이 되면 부저 울림 후 완료 메시지 브로드캐스트
4. `segment_countdown_running` 플래그가 0이 되면 즉시 종료

**역할**:
- 입력받은 숫자부터 0까지 카운트다운
- 1초 간격으로 7세그먼트에 숫자 표시
- 모든 클라이언트에 카운트다운 상태 브로드캐스트
- 0이 되면 부저 울림
- `SEGMENT_STOP` 명령 시 종료

### 11. 데몬 프로세스 변환

**함수**: `main()`

**핵심 로직**:
1. 실행 파일 디렉토리 계산 (데몬 전환 전에 수행)
2. 시그널 핸들러 등록 (SIGINT, SIGTERM)
3. `daemon(0, 0)`으로 데몬 프로세스로 변환
4. PID 파일 생성 (`exec/device_server.pid`)
5. 장치 라이브러리 로딩 (`load_symbols()`)
6. 서버 소켓 생성 및 바인딩 (포트 8080)
7. `accept()` 루프로 클라이언트 연결 대기
8. 각 클라이언트마다 별도 스레드 생성 (`handle_client`)

**역할**:
- 백그라운드 데몬 프로세스로 실행
- PID 파일 생성으로 프로세스 관리 지원
- 장치 라이브러리 로딩 및 초기화
- 멀티 스레드로 여러 클라이언트 동시 처리

### 12. 시그널 처리

**함수**: `signal_handler()`

**핵심 로직**:
1. SIGTERM/SIGINT 시그널 수신 시:
   - 모든 클라이언트에 `SERVER_SHUTDOWN` 메시지 브로드캐스트
   - 모든 스레드 실행 플래그 해제 (cds_monitor_running, segment_countdown_running, quiz_running)
   - 서버 소켓 닫기
   - 동적 라이브러리 해제 (`dlclose()`)
   - PID 파일 삭제
   - 프로세스 종료

**역할**:
- SIGINT/SIGTERM 시그널 처리
- 모든 클라이언트에 종료 메시지 브로드캐스트
- 스레드 종료 신호 전송
- 리소스 정리 (소켓, 라이브러리, PID 파일)

---

## 클라이언트 구현

### 1. 클라이언트 구조 개요

**파일**: `code/client/client.c`

클라이언트는 다음과 같은 구조로 구현되어 있습니다:
- **멀티 스레드**: 메인 스레드(명령 입력), 수신 스레드(서버 메시지 수신), 재연결 스레드(서버 재연결)
- **시그널 처리**: SIGINT만 종료 처리, 다른 시그널 무시
- **입력 검증**: 숫자 검증, 유효하지 않은 메뉴 번호 처리
- **서버 재연결**: 연결 끊김 시 자동 재연결

### 2. 주요 전역 변수

```c
int client_socket = -1;
volatile sig_atomic_t keep_running = 1;
volatile sig_atomic_t server_connected = 0;
volatile sig_atomic_t quiz_active = 0;
pthread_t receive_thread;
pthread_t reconnect_thread;
volatile sig_atomic_t reconnect_running = 0;

static char g_server_ip[16] = "127.0.0.1";
static int g_port = 8080;
```

### 3. 서버 연결

**함수**: `connect_to_server()`

**핵심 로직**:
1. `socket(AF_INET, SOCK_STREAM, 0)`로 TCP 소켓 생성
2. `sockaddr_in` 구조체에 서버 주소 설정 (IP, 포트)
3. `inet_pton()`으로 IP 주소 변환
4. `connect()`로 서버에 연결
5. 성공 시 `server_connected = 1` 설정
6. `quiet` 파라미터로 재연결 시 에러 메시지 출력 제어

**역할**:
- TCP 소켓 생성 및 서버 연결
- 연결 상태 전역 변수 업데이트
- 재연결 시 조용한 모드 지원

### 4. 서버 메시지 수신 스레드

**함수**: `receive_server_messages()`

**핵심 로직**:
1. `recv()`로 서버 메시지 지속 수신
2. 메시지 타입별 처리:
   - `SERVER_SHUTDOWN`: 연결 종료 및 재연결 스레드 시작
   - `QUIZ WRONG`: 현재 줄 지우고 빨간색으로 메시지 출력 후 `answer:` 프롬프트
   - `QUIZ CORRECT/RESULT`: 메시지 출력 후 0.5초 대기, `quiz_active = 0`, 메뉴 출력
   - 일반 메시지: 메시지 타입에 따라 색상 구분 출력 (COMPLETE=녹색, CDS_SENSOR=노란색, 기타=파란색)
3. 연결 끊김 감지 시 재연결 스레드 시작

**역할**:
- 서버로부터 메시지 지속 수신
- 메시지 타입에 따라 다른 색상으로 표시
- 퀴즈 메시지 특별 처리
- 연결 끊김 감지 시 재연결 스레드 시작

### 5. 서버 재연결 스레드

**함수**: `reconnect_to_server_thread()`

**핵심 로직**:
1. 연결 끊김 메시지 출력
2. 3초 간격으로 `connect_to_server()` 호출 (조용한 모드)
3. 재연결 성공 시:
   - 수신 스레드 재시작 (`pthread_create`)
   - 메뉴 출력
4. 연결 실패 시: 이전 줄 지우고 "Connection refused" 메시지 출력
5. `keep_running`이 0이 되거나 재연결 성공 시 종료

**역할**:
- 연결이 끊어졌을 때 3초마다 재연결 시도
- 재연결 성공 시 수신 스레드 재시작 및 메뉴 출력
- 연결 실패 시 메시지 표시

### 6. 명령 전송

**함수**: `send_command()`

**핵심 로직**:
1. `server_connected` 플래그 확인
2. 연결되지 않은 경우: 경고 메시지 출력 후 -1 반환
3. `send()`로 명령 전송
4. 전송 실패 시: 연결 상태 해제, 소켓 닫기, 재연결 스레드 시작

**역할**:
- 서버 연결 상태 확인
- 명령 전송
- 전송 실패 시 재연결 스레드 시작

### 7. 메뉴 출력

**함수**: `print_menu()`

**핵심 로직**:
- ANSI 이스케이프 코드 `\033[H\033[J`로 화면 지우기
- ANSI 색상 코드로 메뉴 테두리 파란색 출력
- 모든 메뉴 항목과 프롬프트 출력

**역할**:
- 화면을 지우고 메뉴 출력
- ANSI 색상 코드로 메뉴 테두리 색상 지정

### 8. 입력 검증

**함수**: `main()` - 입력 검증 부분

**핵심 로직**:
1. 개행 문자 제거 후 문자열 길이 확인
2. 빈 입력인 경우 `continue`
3. 각 문자 검증:
   - 첫 번째 문자가 '-'인 경우 허용 (음수)
   - 나머지 문자는 '0'~'9'만 허용
4. 숫자가 아닌 경우: 빨간색 경고 메시지 출력 후 재입력 요청
5. `atoi()`로 정수 변환

**역할**:
- 입력이 숫자인지 검증
- 빈 입력 처리
- 음수 부호 허용
- 숫자가 아닌 경우 경고 메시지 출력

### 9. 시그널 처리

**함수**: `sig_int_handler()`

**핵심 로직**:
- SIGINT(Ctrl+C)만 처리: `keep_running = 0`, 소켓 종료, 프로세스 종료
- 다른 시그널(SIGTERM, SIGHUP, SIGQUIT, SIGUSR1, SIGUSR2)은 `SIG_IGN`으로 무시

**역할**:
- SIGINT(Ctrl+C)만 종료 처리
- 다른 시그널은 무시하여 강제 종료 방지
- 소켓 정리 후 종료

### 10. 메인 루프

**함수**: `main()`

**핵심 로직**:
1. 명령행 인자 처리 (서버 IP, 포트)
2. 시그널 핸들러 등록
3. 서버 연결 시도 (실패 시 재연결 스레드 시작)
4. 서버 메시지 수신 스레드 시작
5. 메인 루프:
   - `quiz_active`가 아닐 때 메뉴 출력
   - `fgets()`로 사용자 입력 받기
   - 입력 검증 (숫자 확인)
   - `switch` 문으로 명령 처리 및 `send_command()` 호출
6. 프로그램 종료 시: 소켓 종료, 수신 스레드 종료 대기

**역할**:
- 명령행 인자 처리
- 서버 연결 및 수신 스레드 시작
- 메뉴 출력 및 사용자 입력 처리
- 명령 전송
- 프로그램 종료 시 정리

---

## 장치 제어 라이브러리 구현

### 1. LED 제어

**파일**: `code/device_control/src/wiringLED.c`

#### 초기화

```c
int led_init(void) {
    if (!led_initialized) {
        pinMode(LED_PIN, PWM_OUTPUT);  // PWM 모드로 설정
        pwmSetMode(PWM_MODE_MS);      // Mark-Space 모드
        pwmSetRange(1024);             // PWM 범위 설정
        pwmSetClock(32);               // 클럭 설정
        led_initialized = 1;
    }
    return 0;
}
```

**설명**:
- PWM을 사용하여 LED 밝기 조절
- `PWM_MODE_MS`: Mark-Space 모드 (펄스 폭 변조)
- `PWM_RANGE`: 0~1023 범위
- ACTIVE LOW 회로 대응

#### LED 켜기/끄기

**핵심 로직**:
- `led_on()`: `pwmWrite(LED_PIN, 0)` - ACTIVE LOW 회로이므로 0일 때 켜짐
- `led_off()`: `pwmWrite(LED_PIN, 1023)` - 최대값일 때 꺼짐

**설명**:
- ACTIVE LOW 회로: LOW(0)일 때 LED가 켜짐
- `pwmWrite(0)`: 가장 밝게
- `pwmWrite(1023)`: 꺼짐

#### 밝기 조절

**핵심 로직**:
- `switch` 문으로 레벨별 PWM 값 매핑:
  - 레벨 1: 768 (최저, 어두움)
  - 레벨 2: 512 (중간)
  - 레벨 3: 0 (최대, 가장 밝게)
- `pwmWrite()`로 설정

**설명**:
- 3단계 밝기 조절
- ACTIVE LOW이므로 값이 작을수록 밝음

### 2. 부저 제어

**파일**: `code/device_control/src/wiringBuzzer.c`

#### 초기화

```c
int buzzer_init(void) {
    if (!buzzer_initialized) {
        if (softToneCreate(BUZZER_PIN) != 0) {
            fprintf(stderr, "부저 softToneCreate 실패\n");
            return -1;
        }
        buzzer_initialized = 1;
    }
    return 0;
}
```

**설명**:
- `softToneCreate()`: 소프트웨어 PWM을 사용하여 주파수 제어
- 하드웨어 PWM 핀이 아닌 일반 GPIO 핀에서도 사용 가능

#### 기본 제어

**핵심 로직**:
- `buzzer_on()`: `softToneWrite(BUZZER_PIN, 440)` - 440Hz (라 음)
- `buzzer_off()`: `softToneWrite(BUZZER_PIN, 0)` - 소리 끄기

**설명**:
- `softToneWrite()`: 주파수 설정 (0이면 소리 끄기)
- 440Hz: 라(A4) 음

#### 특수 소리 패턴

**핵심 로직**:
- **Warning**: 440Hz, 0.2초
- **Emergency**: 880Hz, 0.2초
- **Success**: 멜로디 배열 [C4(262), E4(330), G4(392), C5(523)] 순차 재생
- **Fail**: 낮은 음 배열 [330, 262, 196] 순차 재생

**설명**:
- 멜로디 배열과 지속 시간 배열을 사용하여 다양한 소리 패턴 생성
- 각 패턴은 `softToneWrite()`로 주파수 설정 후 `usleep()`로 지속 시간 제어

### 3. 7세그먼트 제어

**파일**: `code/device_control/src/wiring7Seg.c`

#### 초기화

```c
int segment_init(void) {
    if (!segment_initialized) {
        for (int i = 0; i < 4; ++i) {
            pinMode(segment_pins[i], OUTPUT);
            digitalWrite(segment_pins[i], LOW);
        }
        segment_initialized = 1;
    }
    return 0;
}
```

**설명**:
- 4개의 세그먼트 핀을 OUTPUT 모드로 설정
- 초기 상태는 모두 LOW

#### 숫자 패턴 정의

```c
// 0~9에 대한 세그먼트 패턴 (d,c,b,a)
static int segment_numbers[10][4] = {
    {0,0,0,0}, // 0
    {0,0,0,1}, // 1
    {0,0,1,0}, // 2
    {0,0,1,1}, // 3
    {0,1,0,0}, // 4
    {0,1,0,1}, // 5
    {0,1,1,0}, // 6
    {0,1,1,1}, // 7
    {1,0,0,0}, // 8
    {1,0,0,1}  // 9
};
```

**설명**:
- 4비트로 0~9 숫자 표현
- 각 비트는 세그먼트 핀에 매핑

#### 숫자 표시

**핵심 로직**:
- 범위 검증 (0~9)
- `segment_numbers[number]` 배열에서 패턴 가져오기
- 4개 핀에 `digitalWrite()`로 HIGH/LOW 출력

**설명**:
- 입력받은 숫자에 해당하는 패턴을 세그먼트 핀에 출력
- 범위 검증 (0~9)

#### 카운트다운

**핵심 로직**:
- 시작 숫자 범위 조정 (0~9)
- 시작 숫자부터 0까지 반복: `segment_display(n)` → `delay(1000)`
- 0이 되면 부저 울림 (`buzzer_on()` → 0.5초 대기 → `buzzer_off()`)

**설명**:
- 입력받은 숫자부터 0까지 카운트다운
- 1초 간격으로 숫자 표시
- 0이 되면 부저 울림
- **주의**: 이 함수는 서버에서 스레드로 구현되어 사용됨

### 4. CDS 센서 제어

**파일**: `code/device_control/src/wiringCDS.c`

#### 초기화

```c
int sensor_init(void) {
    if (!sensor_initialized) {
        pinMode(SENSOR_PIN, INPUT);
        sensor_initialized = 1;
    }
    return 0;
}
```

**설명**:
- 센서 핀을 INPUT 모드로 설정
- 디지털 입력 사용

#### 센서 값 읽기

**핵심 로직**:
- `digitalRead(SENSOR_PIN)`로 디지털 입력 읽기
- 포인터를 통해 값 반환

**설명**:
- 디지털 입력으로 센서 값 읽기
- 0: 어둠, 1: 밝음
- **주의**: 아날로그 센서 사용 시 ADC 연동 필요

### 5. 통합 장치 관리

**파일**: `code/device_control/src/device_manage.c`

#### 전체 장치 초기화

**핵심 로직**:
- 전역 플래그로 중복 초기화 방지
- `wiringPiSetupSys()` 호출 (sysfs를 통한 GPIO 접근)

**설명**:
- `wiringPiSetupSys()`: sysfs를 통한 GPIO 접근 (일반 사용자 권한 가능)
- 전역 플래그로 중복 초기화 방지
- 모든 장치가 공통으로 사용하는 초기화 함수

#### 장치 함수 재사용

**설명**:
- 각 장치 제어 함수는 해당 `wiringXXX.c` 파일에 구현
- `device_manage.c`는 초기화만 담당
- 통합 라이브러리로 빌드 시 모든 함수가 포함됨

---

## 통신 프로토콜

### 1. 명령 형식

클라이언트에서 서버로 전송하는 명령은 문자열 형식입니다:

```
LED_ON\n
LED_OFF\n
LED_BRIGHTNESS <level>\n
BUZZER_ON\n
BUZZER_OFF\n
SEGMENT_DISPLAY <number>\n
SEGMENT_COUNTDOWN <number>\n
SEGMENT_STOP\n
SENSOR_ON\n
SENSOR_OFF\n
QUIZ_START\n
QUIZ_ANSWER <number>\n
```

### 2. 응답 형식

서버에서 클라이언트로 전송하는 응답:

```
LED ON OK\n
LED OFF OK\n
LED BRIGHTNESS OK\n
BUZZER ON OK\n
BUZZER OFF OK\n
SEGMENT DISPLAY OK\n
SEGMENT COUNTDOWN OK\n
SEGMENT STOP OK\n
CDS SENSOR ON OK\n
CDS SENSOR OFF OK\n
QUIZ START: 이 프로젝트의 점수는? (5초 안에 100을 입력하세요!)\n
QUIZ CORRECT: 정답입니다!\n
QUIZ WRONG: 다시 입력하세요\n
QUIZ RESULT: TIMEOVER\n
```

### 3. 브로드캐스트 메시지

서버에서 모든 클라이언트로 자동 전송:

```
CDS_SENSOR: 빛 없음 → LED ON\n
CDS_SENSOR: 빛 감지됨 → LED OFF\n
SEGMENT COUNTDOWN: <number>\n
SEGMENT COUNTDOWN COMPLETE\n
SERVER_SHUTDOWN\n
```

### 4. 프로토콜 특징

- **텍스트 기반**: 모든 명령과 응답이 문자열
- **줄바꿈 구분**: `\n`으로 명령 구분
- **단방향 명령**: 클라이언트 → 서버 (요청-응답)
- **브로드캐스트**: 서버 → 모든 클라이언트 (이벤트 알림)

---

## 스레드 동기화

### 1. 뮤텍스 사용

```c
// CDS 센서 모니터링
pthread_mutex_t cds_monitor_mutex = PTHREAD_MUTEX_INITIALIZER;

// 7세그먼트 카운트다운
pthread_mutex_t segment_countdown_mutex = PTHREAD_MUTEX_INITIALIZER;

// 퀴즈
pthread_mutex_t quiz_mutex = PTHREAD_MUTEX_INITIALIZER;

// 클라이언트 목록
pthread_mutex_t client_list_mutex = PTHREAD_MUTEX_INITIALIZER;
```

**역할**:
- 공유 자원 접근 보호
- 스레드 안전성 보장

### 2. volatile 변수

```c
volatile int cds_monitor_running = 0;
volatile int segment_countdown_running = 0;
volatile int quiz_running = 0;
```

**역할**:
- 컴파일러 최적화 방지
- 다른 스레드에서의 변경 사항 즉시 반영

---

## 에러 처리

### 1. 서버 측

- **라이브러리 로드 실패**: 서버 종료
- **소켓 생성 실패**: 에러 로그 기록
- **클라이언트 연결 실패**: 다음 클라이언트 대기
- **명령 파싱 실패**: "UNKNOWN COMMAND" 반환

### 2. 클라이언트 측

- **서버 연결 실패**: 재연결 스레드 시작
- **명령 전송 실패**: 재연결 시도
- **입력 검증 실패**: 경고 메시지 출력 및 재입력 요청

### 3. 장치 제어 측

- **초기화 실패**: -1 반환 및 에러 메시지 출력
- **범위 초과**: -1 반환 및 에러 메시지 출력
- **GPIO 접근 실패**: 에러 로그 기록

---

## 참고 자료

- **서버 코드**: `code/server/server.c`
- **클라이언트 코드**: `code/client/client.c`
- **LED 제어**: `code/device_control/src/wiringLED.c`
- **부저 제어**: `code/device_control/src/wiringBuzzer.c`
- **7세그먼트 제어**: `code/device_control/src/wiring7Seg.c`
- **CDS 센서 제어**: `code/device_control/src/wiringCDS.c`
- **통합 관리**: `code/device_control/src/device_manage.c`

