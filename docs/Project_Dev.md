# 프로젝트 개발 진행 현황

## 프로젝트 개요

**주제**: TCP를 이용한 원격 장치 제어 프로그램
- 서버: 라즈베리파이 4
- 클라이언트: 우분투 리눅스

## 구현 내용

### 기본 요구사항
- ✅ 멀티 프로세스/스레드를 이용한 장치 제어
- ✅ 대상 원격 장치: LED/부저/조도 센서/7세그먼트
- ✅ 장치 제어: Shared Library 형식으로 작성
- ✅ 동적 라이브러리 기능 (장치 기능 변경 시 라이브러리만 업로드)
- ✅ 클라이언트 프로그램 실행 도중 강제 종료 방지 (SIGINT만 종료)
- ✅ 서버는 Daemon process 형식으로 구성
- ✅ 빌드 자동화 (Makefile)

## 장치별 제어 구현 기능

### LED
- ✅ 클라이언트에서 ON/OFF 제어
- ✅ 밝기 조절 (최대/중간/최저 3단계)

### 부저
- ✅ 클라이언트에서 소리 ON/OFF 제어
- ✅ 경고음/비상음/실패음/성공음 (퀴즈 기능에서 사용)

### 조도 센서 (CDS)
- ✅ 클라이언트에서 조도 센서 값 확인
- ✅ 빛이 감지되지 않으면 LED ON
- ✅ 빛이 감지되면 LED OFF
- ✅ 센서 값 변경 시 모든 클라이언트로 브로드캐스트

### 7세그먼트
- ✅ 클라이언트에서 전송한 숫자 (0~9) 표시
- ✅ 1초 지날 때마다 -1씩 감소 표시
- ✅ 0이 되면 부저 울림
- ✅ 카운트다운 중단 기능

### 퀴즈 기능 (추가 구현)
- ✅ 프로젝트 점수 맞추기 퀴즈
- ✅ 5초 시간 제한
- ✅ 카운트다운 중 부저 경고음/비상음
- ✅ 정답 시 성공음, 시간 초과 시 실패음
- ✅ 정답/오답/시간 초과 메시지 표시

## 개발 진행 단계

### 1단계: 기본 인프라 구축 ✅
- [x] 프로젝트 폴더 구조 생성
- [x] 빌드 시스템 구성 (상위 Makefile + 하위 Makefile)
- [x] TCP 서버/클라이언트 기본 통신 구현
- [x] 기본 메뉴 UI 구현

### 2단계: 하드웨어 제어 라이브러리 개발 ✅
- [x] 장치별 Shared Library 구조 설계
- [x] LED 제어 라이브러리 (밝기 3단계 조절 포함)
- [x] 부저 제어 라이브러리
- [x] 조도 센서 라이브러리
- [x] 7세그먼트 라이브러리 (숫자 표시 및 카운트다운)
- [x] 통합 라이브러리 (`libdevice_manage.so`) 빌드
- [x] `wiringPiSetupSys()` 사용으로 일반 사용자 실행 가능

### 3단계: 서버 구현 ✅
- [x] 데몬 프로세스로 변환 (`daemon(0, 0)`)
- [x] 멀티 스레드 구조 구현
  - 클라이언트별 처리 스레드
  - CDS 센서 모니터링 전용 스레드
  - 7세그먼트 카운트다운 전용 스레드
  - 퀴즈 처리 전용 스레드
- [x] TCP 서버 소켓 구현
- [x] 동적 라이브러리 로딩 (`dlopen/dlsym`)
- [x] 클라이언트 명령 문자열과 장치 제어 함수 매핑
- [x] 실행 파일 기준 절대 경로 계산 (`get_exe_directory`)
- [x] 로그 파일 자동 기록 (`misc/device_server.log`)
- [x] PID 파일 관리 (`exec/device_server.pid`)
- [x] 시그널 처리 (SIGINT/SIGTERM에서 정상 종료)

### 4단계: 클라이언트 구현 ✅
- [x] TCP 클라이언트 소켓 구현
- [x] 메뉴 UI 구현 (ANSI 컬러 지원)
- [x] 시그널 처리 (SIGINT만 종료, 다른 시그널 무시)
- [x] 서버 메시지 수신 전용 스레드
- [x] 서버 재연결 기능 (자동 재연결 시도)
- [x] 입력 검증 (숫자 검증, 유효하지 않은 메뉴 번호 처리)
- [x] 서버와의 통신 프로토콜 구현

### 5단계: 고급 기능 구현 ✅
- [x] 조도 센서 자동 제어 (센서 감시 스레드 + LED 제어)
- [x] 7세그먼트 카운트다운 기능 (1초마다 -1, 0되면 부저)
- [x] 멀티 스레드를 통한 동시 장치 제어
- [x] CDS 센서 값 변경 시 모든 클라이언트로 브로드캐스트
- [x] 퀴즈 기능 구현

### 6단계: 테스트 및 문서화 ✅
- [x] 실행 테스트
- [x] README.md 작성
- [x] 개발 문서 작성 (본 파일)
- [ ] running.txt 작성 (실행 화면 캡처)

## 주요 구현 세부사항

### 서버 구조
1. **데몬 프로세스**
   - `daemon(0, 0)` 함수 사용
   - 실행 파일 기준 절대 경로 계산
   - PID 파일 및 로그 파일 자동 관리

2. **멀티 스레드**
   - 클라이언트별 처리 스레드 (동시 접속 지원)
   - CDS 센서 모니터링 스레드 (`SENSOR_ON`/`SENSOR_OFF`로 제어)
   - 7세그먼트 카운트다운 스레드 (`SEGMENT_COUNTDOWN`/`SEGMENT_STOP`로 제어)
   - 퀴즈 처리 스레드 (`QUIZ_START`로 시작)

3. **동적 라이브러리 로딩**
   - `dlopen`으로 `libdevice_manage.so` 로드
   - `dlsym`으로 각 장치 제어 함수 심볼 로드
   - 서버 종료 시 `dlclose`로 정리

### 클라이언트 구조
1. **멀티 스레드**
   - 메인 스레드: 메뉴 표시 및 명령 입력
   - 서버 메시지 수신 스레드: 비동기 메시지 처리
   - 서버 재연결 스레드: 연결 끊김 시 자동 재연결

2. **시그널 처리**
   - SIGINT(Ctrl+C)만 종료 처리
   - 다른 시그널(SIGTERM, SIGHUP, SIGQUIT, SIGUSR1, SIGUSR2) 무시

3. **서버 재연결**
   - 연결 끊김 감지 시 자동으로 재연결 스레드 시작
   - 3초마다 재연결 시도
   - 재연결 성공 시 자동으로 메뉴 복귀

4. **입력 검증**
   - 숫자가 아닌 입력 시 경고 메시지
   - 유효하지 않은 메뉴 번호 입력 시 경고 메시지

## 문제점 및 해결 과정

### 1. PWM 제어 시 권한 문제
**문제**: 서버에서 PWM 제어 시 권한 문제 발생
```
pwmWrite: Unable to do this when using /dev/gpiomem. Try sudo?
```

**해결**: 
- 우선 `sudo` 권한으로 실행하여 확인
- 추후 daemon 서비스 생성 시 권한 변경 예정
- `wiringPiSetupSys()` 사용으로 일반 사용자 실행 가능 (단, `gpio` 그룹 권한 필요)

### 2. PWM으로 LED 값 제어 시 Active Low 방식 코드 작성
**문제**: 
- GPIO write는 되는데 PWM으로는 동작하지 않음
- Active Low 방식에 맞는 코드 작성 필요

**원인 분석**:
- 라즈베리파이 하드웨어 자체적으로 지원하는 PWM 전용 핀은 개수가 제한적
- 각 GPIO 핀의 기능 확인 필요

**해결**:
- LED PIN을 physical 32번 핀(GPIO.26)으로 변경
- `wiringPi`의 `softPwmWrite` 함수 사용
- `softPwmCreate`로 0~100 범위의 PWM 생성
- Active Low 방식에 맞게 PWM 값 반전 처리

**참고 코드**:
```c
#include <wiringPi.h>
#include <softPwm.h>

#define PIN_LED 1 // wiringPi 번호 기준

softPwmCreate(PIN_LED, 0, 100);
softPwmWrite(PIN_LED, brightness); // 0~100 범위
```

### 3. 서버 로직 연결 유지 문제
**문제**: 서버 로직이 **한 번 recv → 응답 → close(client_socket)**로 설계되어 한 번 명령어 수행 시 클라이언트와 연결이 끊어짐

**해결**: 
- `accept`를 사용하여 클라이언트와의 연결을 유지하도록 수정
- 멀티 스레드를 이용하여 여러 클라이언트가 동시에 접근 가능하도록 처리
- 클라이언트별 처리 스레드 생성으로 동시 접속 지원

### 4. CDS 탐지와 7Segment 스레드 대기 문제
**문제**: CDS 센서 탐지와 7세그먼트 스레드가 서로 대기하는 문제 발생

**해결**: 
- CDS 센서 모니터링을 별도 스레드로 분리
- 7세그먼트 카운트다운을 별도 스레드로 분리
- 각 스레드가 독립적으로 동작하도록 구현
- 스레드 간 동기화를 위한 mutex 사용

### 5. 데몬 프로세스 변경 후 로그 파일 작성과 경로 문제
**문제**: `daemon(0, 0)` 사용 후 작업 디렉토리가 루트(`/`)로 변경되어 상대 경로 사용 불가

**해결**: 
- `readlink("/proc/self/exe")`를 사용하여 현재 실행 중인 파일의 경로를 받아옴
- `get_exe_directory()` 함수로 실행 파일 기준 절대 경로 계산
- 라이브러리, 로그 파일, PID 파일 경로를 절대 경로로 생성
- 데몬 환경에서도 정상적으로 파일 접근 가능

### 6. 서버 종료 시 리소스 정리
**문제**: 시그널로 종료 시 스레드 및 소켓이 정리되지 않음

**해결**: 시그널 핸들러에서 정리 작업 수행
- 모든 클라이언트 소켓 닫기
- 스레드 종료 대기
- 동적 라이브러리 해제
- PID 파일 삭제

### 7. 클라이언트 시그널 처리
**문제**: 다양한 시그널로 인한 강제 종료

**해결**: SIGINT만 종료 처리, 다른 시그널 무시
- `signal(SIGTERM, SIG_IGN)` 등으로 무시 설정
- SIGINT에서만 정상 종료 처리

### 8. 서버 재연결 기능
**문제**: 서버 연결이 끊어지면 클라이언트가 종료됨

**해결**: 재연결 스레드 구현
- 연결 끊김 감지 시 재연결 스레드 시작
- 3초마다 재연결 시도
- 재연결 성공 시 수신 스레드 재시작

### 9. 퀴즈 기능 구현
**문제**: 시간 제한이 있는 퀴즈 기능 구현

**해결**: 퀴즈 전용 스레드 구현
- 5초 카운트다운 스레드
- 정확한 타이밍을 위한 `clock_gettime()` 사용
- 부저 소리와 카운트다운 동기화

### 10. 퀴즈 풀이 이후 명령 수행 불가 문제
**문제**: 퀴즈 풀이 이후 int 값으로 인한 command 수행 불가
- 퀴즈 종료 후 메인 루프로 복귀하지 못하는 문제
- `fgets`가 블로킹되어 있어 퀴즈 종료 시 즉시 반응하지 못함

**해결**: 
- 퀴즈 입력 루프에서 `quiz_active` 플래그 확인
- 퀴즈 종료 시 `quiz_active = 0`으로 설정하여 루프 종료
- 메인 루프에서 `quiz_active`가 0이면 즉시 `fgets` 호출하여 입력 받기
- 입력 검증 로직 추가로 숫자가 아닌 입력 처리
- 퀴즈 종료 후 바로 메뉴 선택 가능하도록 개선

## 제출 형식 준비

### 폴더 구조
```
Veda_Project/
├── code/
│   ├── client/
│   ├── server/
│   └── device_control/
├── docs/
│   ├── manual.pdf (or .pptx)
│   ├── README.md
│   └── running.txt
├── exec/
│   ├── client
│   ├── server
│   └── lib/
│       └── libdevice_manage.so
├── misc/
└── README.md
```

### 제출 파일
- 개발 문서 (manual.pdf/pptx)
- 개발 일정 및 세부 구현 내용 (본 파일)
- 문제점 및 보완 사항 (본 파일)
- 개발 소스 코드 및 빌드 방법 (README.md)
- 실행 과정 Text 파일 (running.txt)

## 최종 상태 (2025-12-29 기준)

모든 기본 요구사항 및 고급 기능이 구현 완료되었습니다.

### 완료된 기능
- ✅ 멀티 스레드 구조
- ✅ 데몬 프로세스
- ✅ 동적 라이브러리 로딩
- ✅ 시그널 처리
- ✅ 빌드 자동화
- ✅ 모든 장치 제어 기능
- ✅ 퀴즈 기능
- ✅ 서버 재연결 기능
- ✅ 입력 검증

### 남은 작업
- [ ] running.txt 작성 (실행 화면 캡처)
