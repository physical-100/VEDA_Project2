# 퀴즈 기능 구현 문서

## 목차
1. [기능 개요](#기능-개요)
2. [구현 구조](#구현-구조)
3. [서버 측 구현](#서버-측-구현)
4. [클라이언트 측 구현](#클라이언트-측-구현)
5. [부저 소리 패턴](#부저-소리-패턴)
6. [동작 흐름](#동작-흐름)
7. [주요 함수 설명](#주요-함수-설명)

---

## 기능 개요

퀴즈 기능은 "프로젝트 점수 맞추기" 게임으로, 다음과 같은 특징을 가집니다:

- **시간 제한**: 5초 내에 정답을 입력해야 함
- **정답**: 100점
- **7세그먼트 디스플레이**: 남은 시간을 표시 (5 → 4 → 3 → 2 → 1 → 0)
- **부저 피드백**:
  - 5~3초: 경고음 (warning)
  - 2~1초: 비상음 (emergency)
  - 정답 시: 성공음 (success - 딩동댕)
  - 시간 초과 시: 실패음 (fail - 쿠쿵)
- **실시간 피드백**: 오답 시 즉시 알림 및 재입력 가능

---

## 구현 구조

### 전체 구조
```
클라이언트                    서버
    |                          |
    |-- QUIZ_START ----------->|
    |                          |-- quiz_thread_func() 시작
    |                          |   (5초 카운트다운 스레드)
    |                          |
    |<-- QUIZ START 메시지 -----|
    |                          |
    |-- QUIZ_ANSWER 50 ------->|
    |                          |-- 정답 확인
    |<-- QUIZ WRONG -----------|
    |                          |
    |-- QUIZ_ANSWER 100 ------>|
    |                          |-- quiz_correct = 1
    |                          |-- 카운트다운 스레드 종료
    |<-- QUIZ CORRECT ---------|
    |                          |
```

### 주요 구성 요소

#### 서버 측
- **퀴즈 스레드**: `quiz_thread_func()` - 5초 카운트다운 및 부저 제어
- **퀴즈 상태 변수**: 
  - `quiz_running`: 퀴즈 진행 중 여부
  - `quiz_correct`: 정답 여부
- **뮤텍스**: `quiz_mutex` - 스레드 안전성 보장

#### 클라이언트 측
- **퀴즈 입력 루프**: 메인 스레드에서 사용자 입력 받기
- **퀴즈 상태 플래그**: `quiz_active` - 퀴즈 활성 상태
- **메시지 수신 스레드**: 서버 응답 비동기 처리

---

## 서버 측 구현

### 1. 퀴즈 시작 처리 (`handle_command`)

**위치**: `code/server/server.c` (475-489줄)

```c
else if (strncmp(cmd, "QUIZ_START", 10) == 0) {
    // 퀴즈 시작: 5초 카운트다운 + 부저
    pthread_mutex_lock(&quiz_mutex);
    if (quiz_running) {
        pthread_mutex_unlock(&quiz_mutex);
        return "QUIZ ALREADY RUNNING\n";
    }
    quiz_correct = 0;
    if (pthread_create(&quiz_thread, NULL, quiz_thread_func, NULL) != 0) {
        pthread_mutex_unlock(&quiz_mutex);
        return "QUIZ START FAILED\n";
    }
    pthread_detach(quiz_thread);
    pthread_mutex_unlock(&quiz_mutex);
    return "QUIZ START: 이 프로젝트의 점수는? (5초 안에 100을 입력하세요!)\n";
}
```

**동작**:
1. 뮤텍스로 퀴즈 상태 보호
2. 이미 퀴즈가 실행 중이면 에러 반환
3. `quiz_correct` 초기화
4. 퀴즈 스레드 생성 및 분리
5. 시작 메시지 반환

### 2. 퀴즈 답변 처리 (`handle_command`)

**위치**: `code/server/server.c` (490-514줄)

```c
else if (strncmp(cmd, "QUIZ_ANSWER", 11) == 0) {
    // 사용자가 입력한 정답 확인
    if (!quiz_running) {
        return "QUIZ NOT RUNNING\n";
    }
    // 공백 다음 숫자 파싱
    const char *arg = cmd + 11;
    while (*arg == ' ') arg++;
    int ans = atoi(arg);

    if (ans == 100) {
        // 정답
        quiz_correct = 1;
        return "QUIZ CORRECT: 정답입니다!\n";
    } else {
        // 오답: warning 패턴 1회
        if (libs->buzzer_warning) {
            libs->buzzer_warning();
        } else if (libs->buzzer_on && libs->buzzer_off) {
            libs->buzzer_on();
            usleep(150000);
            libs->buzzer_off();
        }
        return "QUIZ WRONG: 다시 입력하세요\n";
    }
}
```

**동작**:
1. 퀴즈 실행 중인지 확인
2. 명령어에서 답변 숫자 파싱
3. 정답(100)이면 `quiz_correct = 1` 설정
4. 오답이면 경고음 재생 및 오답 메시지 반환

### 3. 퀴즈 카운트다운 스레드 (`quiz_thread_func`)

**위치**: `code/server/server.c` (729-829줄)

#### 전체 구조
```c
static void *quiz_thread_func(void *arg)
{
    // 1. 퀴즈 상태 초기화
    pthread_mutex_lock(&quiz_mutex);
    quiz_running = 1;
    quiz_correct = 0;
    pthread_mutex_unlock(&quiz_mutex);

    int n = 5;  // 5초부터 시작

    // 2. 카운트다운 루프 (5 → 4 → 3 → 2 → 1 → 0)
    while (n >= 0) {
        // 정답 확인 (즉시 종료)
        if (quiz_correct) {
            break;
        }

        // 7세그먼트에 숫자 표시
        if (g_libs.segment_display) {
            g_libs.segment_display(n);
        }

        // 부저 소리 패턴
        // - 5~3초: warning
        // - 2~1초: emergency
        // - 0초: fail

        // 정확한 1초 간격 유지
        // (부저 소리 시간을 고려한 타이밍 제어)

        n--;
    }

    // 3. 결과 처리
    if (quiz_correct) {
        // 정답: success 소리
    } else {
        // 시간 초과: fail 소리 + 브로드캐스트
    }

    // 4. 퀴즈 종료
    pthread_mutex_lock(&quiz_mutex);
    quiz_running = 0;
    pthread_mutex_unlock(&quiz_mutex);
    
    return NULL;
}
```

#### 타이밍 제어 (정확한 1초 간격)

```c
// 부저 소리 시간 측정 후 나머지 시간만큼만 대기 (정확히 1초)
struct timespec start_time, end_time;
clock_gettime(CLOCK_MONOTONIC, &start_time);

// 부저 소리 재생
if (n > 2) {
    buzzer_warning();  // 약 0.2초
} else if (n > 0) {
    buzzer_emergency(); // 약 0.2초
}

// 경과 시간 계산
clock_gettime(CLOCK_MONOTONIC, &end_time);
long elapsed_ns = (end_time.tv_sec - start_time.tv_sec) * 1000000000L + 
                 (end_time.tv_nsec - start_time.tv_nsec);
long elapsed_us = elapsed_ns / 1000;
long remaining_us = 1000000 - elapsed_us;  // 1초(1000000us) - 경과 시간

// 나머지 시간만큼 대기
if (remaining_us > 0) {
    usleep(remaining_us);
}
```

**핵심 포인트**:
- `clock_gettime(CLOCK_MONOTONIC)` 사용으로 정확한 시간 측정
- 부저 소리 재생 시간을 측정하여 정확히 1초 간격 유지
- 부저 소리가 0.2초이므로 나머지 0.8초만 대기

#### 부저 소리 패턴

```c
// 5~3초: 경고음 (warning)
if (n > 2) {
    if (g_libs.buzzer_warning) {
        g_libs.buzzer_warning();
    }
}
// 2~1초: 비상음 (emergency)
else if (n > 0) {
    if (g_libs.buzzer_emergency) {
        g_libs.buzzer_emergency();
    }
}
// 0초: 실패음 (fail)
if (n == 0) {
    if (g_libs.buzzer_fail) {
        g_libs.buzzer_fail();
    }
    break;
}
```

#### 결과 처리

```c
if (quiz_correct) {
    // 정답: success 멜로디 (딩동댕)
    if (g_libs.buzzer_success) {
        g_libs.buzzer_success();
    }
    // CORRECT 메시지는 QUIZ_ANSWER 핸들러에서 이미 전송됨
} else {
    // 시간 초과: fail 소리 + 브로드캐스트
    broadcast_to_clients("QUIZ RESULT: TIMEOVER\n");
}
```

---

## 클라이언트 측 구현

### 1. 퀴즈 시작 (메인 루프)

**위치**: `code/client/client.c` (518-577줄)

```c
case 11:
{
    // 퀴즈 시작
    quiz_active = 1;  // 퀴즈 활성 상태 설정
    if (send_command("QUIZ_START\n") < 0) {
        // 서버 연결이 안 되어있으면 퀴즈 시작 불가
        quiz_active = 0;
        break;
    }
    
    // 퀴즈 입력 루프
    while (keep_running && server_connected && quiz_active) {
        // 퀴즈가 끝났는지 먼저 확인
        if (!quiz_active) {
            break;
        }
        
        char answer[BUFFER_SIZE];
        printf("answer: ");
        fflush(stdout);
        
        // 사용자 입력 받기
        if (!fgets(answer, sizeof(answer), stdin)) {
            break;
        }
        
        // 퀴즈가 끝났는지 확인 (입력 받은 직후)
        if (!quiz_active) {
            break;
        }
        
        // 빈 줄이면 퀴즈 입력 종료
        if (answer[0] == '\n') {
            break;
        }
        
        // 서버 연결 상태 확인
        if (!server_connected || client_socket == -1) {
            printf(ANSI_COLOR_RED "서버와의 연결이 끊겼습니다. 퀴즈를 종료합니다.\n" ANSI_COLOR_RESET);
            break;
        }
        
        // 답변 전송
        snprintf(input, sizeof(input), "QUIZ_ANSWER %s", answer);
        if (send_command(input) < 0) {
            break;
        }
        
        // QUIZ RESULT 메시지를 받았는지 다시 확인 (응답 후)
        if (!quiz_active) {
            break;
        }
    }
    
    quiz_active = 0;  // 확실히 종료
    break;
}
```

**동작**:
1. `quiz_active = 1` 설정
2. `QUIZ_START` 명령 전송
3. 사용자 입력 루프 시작
4. 입력 받은 후 `QUIZ_ANSWER` 명령 전송
5. `quiz_active`가 0이 되면 루프 종료

### 2. 서버 메시지 처리 (수신 스레드)

**위치**: `code/client/client.c` (205-230줄)

#### QUIZ WRONG 처리
```c
if (strstr(buffer, "QUIZ WRONG")) {
    printf("\r\033[2K");  // 현재 줄 지우기 (answer: 프롬프트 포함)
    printf(ANSI_COLOR_RED "[INFO] %s" ANSI_COLOR_RESET, buffer);
    printf("answer: ");  // 메시지 출력 후 다시 answer: 프롬프트 표시
    fflush(stdout);
}
```

**동작**:
- 현재 줄을 지우고 오답 메시지를 빨간색으로 표시
- `answer: ` 프롬프트를 다시 표시하여 재입력 가능

#### QUIZ CORRECT 처리
```c
else if (strstr(buffer, "QUIZ CORRECT")) {
    printf("\r\033[2K");  // 현재 줄 지우기
    printf(ANSI_COLOR_BLUE "[INFO] %s" ANSI_COLOR_RESET, buffer);
    fflush(stdout);
    usleep(500000);  // 0.5초 대기
    quiz_active = 0;  // 퀴즈 입력 루프 종료
    printf("\n");
    print_menu();  // 메뉴 대시보드 출력
}
```

**동작**:
- 정답 메시지를 파란색으로 표시
- 0.5초 대기 후 `quiz_active = 0` 설정
- 메뉴 출력하여 메인 루프로 복귀

#### QUIZ RESULT (TIMEOVER) 처리
```c
else if (strstr(buffer, "QUIZ RESULT")) {
    printf("\r\033[2K");  // 현재 줄 지우기
    printf(ANSI_COLOR_BLUE "[INFO] %s" ANSI_COLOR_RESET, buffer);
    fflush(stdout);
    usleep(500000);  // 0.5초 대기
    quiz_active = 0;  // 퀴즈 입력 루프 종료
    printf("\n");
    print_menu();  // 메뉴 대시보드 출력
}
```

**동작**:
- 시간 초과 메시지를 표시
- 0.5초 대기 후 `quiz_active = 0` 설정
- 메뉴 출력하여 메인 루프로 복귀

---

## 부저 소리 패턴

### 구현 위치
`code/device_control/src/wiringBuzzer.c`

### 1. Warning (경고음)
**사용 시점**: 5~3초, 오답 입력 시

```c
int buzzer_warning(void) {
    if (buzzer_init() < 0) return -1;
    
    // 0.2초 짧은 경고음
    softToneWrite(BUZZER_PIN, 440); // 라(A4) 음
    usleep(200000);                // 0.2초 소리
    softToneWrite(BUZZER_PIN, 0);
    return 0;
}
```

**특징**: 낮은 음(440Hz), 0.2초

### 2. Emergency (비상음)
**사용 시점**: 2~1초

```c
int buzzer_emergency(void) {
    if (buzzer_init() < 0) return -1;
    
    // 0.2초 비상 사이렌
    softToneWrite(BUZZER_PIN, 880); // 높은 라
    usleep(200000);                // 0.2초 소리
    softToneWrite(BUZZER_PIN, 0);
    return 0;
}
```

**특징**: 높은 음(880Hz), 0.2초

### 3. Success (성공음)
**사용 시점**: 정답 입력 시

```c
int buzzer_success(void) {
    if (buzzer_init() < 0) return -1;
    
    int melody[] = {NOTE_C4, NOTE_E4, NOTE_G4, NOTE_C5};
    int duration[] = {150000, 150000, 150000, 300000};
    
    for(int i = 0; i < 4; i++) {
        softToneWrite(BUZZER_PIN, melody[i]);
        usleep(duration[i]);
    }
    softToneWrite(BUZZER_PIN, 0);
    return 0;
}
```

**특징**: 
- 멜로디: 도-미-솔-도 (C-E-G-C)
- 주파수: 262Hz, 330Hz, 392Hz, 523Hz
- 총 길이: 약 0.75초

### 4. Fail (실패음)
**사용 시점**: 시간 초과 시

```c
int buzzer_fail(void) {
    if (buzzer_init() < 0) return -1;
    
    // 높은 음에서 낮은 음으로 (띠-로-리-)
    int notes[] = {330, 262, 196}; // 미 - 도 - 솔(낮은)
    int durations[] = {200000, 200000, 400000};
    
    for(int i = 0; i < 3; i++) {
        softToneWrite(BUZZER_PIN, notes[i]);
        usleep(durations[i]);
    }
    softToneWrite(BUZZER_PIN, 0);
    return 0;
}
```

**특징**:
- 멜로디: 미-도-솔(낮은) (E-C-G)
- 주파수: 330Hz → 262Hz → 196Hz
- 총 길이: 약 0.8초
- 낮은 "쿠쿵" 소리

---

## 동작 흐름

### 시나리오 1: 정답 입력

```
시간    서버 동작                    클라이언트 동작
─────────────────────────────────────────────────────────
0초     QUIZ_START 수신
        quiz_thread_func() 시작
        n = 5, segment_display(5)
        buzzer_warning()              QUIZ START 메시지 수신
                                      answer: 프롬프트 표시
─────────────────────────────────────────────────────────
1초     n = 4, segment_display(4)
        buzzer_warning()
─────────────────────────────────────────────────────────
2초     n = 3, segment_display(3)
        buzzer_warning()
─────────────────────────────────────────────────────────
3초     n = 2, segment_display(2)
        buzzer_emergency()            사용자 입력: 50
                                      QUIZ_ANSWER 50 전송
─────────────────────────────────────────────────────────
        QUIZ_ANSWER 50 수신
        buzzer_warning()               QUIZ WRONG 메시지 수신
        return "QUIZ WRONG"            answer: 프롬프트 재표시
─────────────────────────────────────────────────────────
4초     n = 1, segment_display(1)
        buzzer_emergency()            사용자 입력: 100
                                      QUIZ_ANSWER 100 전송
─────────────────────────────────────────────────────────
        QUIZ_ANSWER 100 수신
        quiz_correct = 1               QUIZ CORRECT 메시지 수신
        quiz_thread_func() 종료        quiz_active = 0
        buzzer_success()               메뉴 출력
```

### 시나리오 2: 시간 초과

```
시간    서버 동작                    클라이언트 동작
─────────────────────────────────────────────────────────
0초     QUIZ_START 수신
        quiz_thread_func() 시작
        n = 5, segment_display(5)
        buzzer_warning()              QUIZ START 메시지 수신
                                      answer: 프롬프트 표시
─────────────────────────────────────────────────────────
1초     n = 4, segment_display(4)
        buzzer_warning()
─────────────────────────────────────────────────────────
2초     n = 3, segment_display(3)
        buzzer_warning()
─────────────────────────────────────────────────────────
3초     n = 2, segment_display(2)
        buzzer_emergency()
─────────────────────────────────────────────────────────
4초     n = 1, segment_display(1)
        buzzer_emergency()
─────────────────────────────────────────────────────────
5초     n = 0, segment_display(0)
        buzzer_fail()
        broadcast("QUIZ RESULT: TIMEOVER")
        quiz_running = 0              QUIZ RESULT 메시지 수신
                                      quiz_active = 0
                                      메뉴 출력
```

---

## 주요 함수 설명

### 서버 측

#### `quiz_thread_func(void *arg)`
- **역할**: 퀴즈 카운트다운 스레드
- **동작**:
  1. 5초부터 0초까지 카운트다운
  2. 각 초마다 7세그먼트에 숫자 표시
  3. 시간에 따라 부저 소리 재생
  4. 정답 확인 시 즉시 종료
  5. 시간 초과 시 실패음 재생 및 브로드캐스트

#### `handle_command()` - QUIZ_START 처리
- **역할**: 퀴즈 시작 명령 처리
- **동작**:
  1. 퀴즈 실행 중인지 확인
  2. 퀴즈 스레드 생성
  3. 시작 메시지 반환

#### `handle_command()` - QUIZ_ANSWER 처리
- **역할**: 사용자 답변 처리
- **동작**:
  1. 답변 숫자 파싱
  2. 정답(100) 확인
  3. 정답이면 `quiz_correct = 1` 설정
  4. 오답이면 경고음 재생

### 클라이언트 측

#### 메인 루프 - case 11
- **역할**: 퀴즈 입력 루프
- **동작**:
  1. `quiz_active = 1` 설정
  2. `QUIZ_START` 명령 전송
  3. 사용자 입력 받기
  4. `QUIZ_ANSWER` 명령 전송
  5. `quiz_active` 확인하여 루프 종료

#### `receive_server_messages()` - QUIZ 메시지 처리
- **역할**: 서버 응답 처리
- **동작**:
  1. `QUIZ WRONG`: 오답 메시지 표시, 프롬프트 재표시
  2. `QUIZ CORRECT`: 정답 메시지 표시, 메뉴 출력
  3. `QUIZ RESULT`: 시간 초과 메시지 표시, 메뉴 출력

---

## 스레드 동기화

### 뮤텍스 사용
```c
pthread_mutex_t quiz_mutex = PTHREAD_MUTEX_INITIALIZER;
```

**보호 대상**:
- `quiz_running`: 퀴즈 실행 상태
- `quiz_correct`: 정답 여부

**사용 위치**:
1. 퀴즈 시작 시: 상태 초기화
2. 퀴즈 답변 처리 시: `quiz_correct` 설정
3. 퀴즈 종료 시: `quiz_running = 0` 설정

### 플래그 기반 통신
- `quiz_correct`: 퀴즈 스레드가 정답 여부 확인
- `quiz_active`: 클라이언트 메인 루프가 퀴즈 종료 확인

---

## 타이밍 정확도

### 문제점
- 부저 소리 재생 시간(약 0.2초)을 고려하지 않으면 1초 간격이 정확하지 않음
- 단순히 `sleep(1)`을 사용하면 실제 간격이 1.2초가 됨

### 해결 방법
```c
struct timespec start_time, end_time;
clock_gettime(CLOCK_MONOTONIC, &start_time);

// 부저 소리 재생 (약 0.2초)
buzzer_warning();

// 경과 시간 측정
clock_gettime(CLOCK_MONOTONIC, &end_time);
long elapsed_ns = (end_time.tv_sec - start_time.tv_sec) * 1000000000L + 
                 (end_time.tv_nsec - start_time.tv_nsec);
long elapsed_us = elapsed_ns / 1000;
long remaining_us = 1000000 - elapsed_us;  // 1초 - 경과 시간

// 나머지 시간만큼 대기
if (remaining_us > 0) {
    usleep(remaining_us);
}
```

**효과**: 정확히 1초 간격으로 카운트다운 수행

---

## 에러 처리

### 서버 측
1. **퀴즈 이미 실행 중**: `QUIZ ALREADY RUNNING` 반환
2. **퀴즈 실행 중 아님**: `QUIZ NOT RUNNING` 반환
3. **스레드 생성 실패**: `QUIZ START FAILED` 반환

### 클라이언트 측
1. **서버 연결 끊김**: 퀴즈 종료 및 메시지 표시
2. **명령 전송 실패**: 루프 종료
3. **입력 중 퀴즈 종료**: 입력 무시 및 메뉴 복귀

---

## 개선 가능 사항

1. **다중 클라이언트 지원**: 현재는 모든 클라이언트가 동일한 퀴즈를 공유
2. **점수 시스템**: 정답 시간에 따른 점수 차등 부여
3. **문제 랜덤화**: 다양한 문제 출제
4. **히스토리 저장**: 퀴즈 결과 기록

---

## 참고 자료

- **서버 코드**: `code/server/server.c`
- **클라이언트 코드**: `code/client/client.c`
- **부저 제어**: `code/device_control/src/wiringBuzzer.c`
- **7세그먼트 제어**: `code/device_control/src/wiring7Seg.c`

